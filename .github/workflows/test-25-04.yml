name: Toolchain Smoketest

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to test"
        type: string
        default: "main"
      builder_image:
        description: "Builder container image"
        type: string
        default: "docker.io/mr8c3/builder:latest"
      skip_cmake:
        description: "Skip cmake hugetlbfs/Boost check"
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  ASMFLAGS: -march=haswell
  CC: gcc-15
  CFLAGS: -march=haswell
  CXX: g++-15
  CXXFLAGS: -march=haswell -DQUILL_ACTIVE_LOG_LEVEL=QUILL_LOG_LEVEL_CRITICAL

jobs:
  smoke:
    runs-on: self-hosted
    container:
      image: ${{ inputs.builder_image }}
      options: --privileged --user 0:0
    continue-on-error: true
    steps:

      - name: Create dummy crate & build
        shell: bash
        env:
          SELFTEST_SKIP_CMAKE: ${{ inputs.skip_cmake && '1' || '0' }}
        run: |
          set -euo pipefail

          # workspace
          rm -rf toolchain-smoketest
          mkdir -p toolchain-smoketest/{src,csrc,cxxsrc}

          # Cargo.toml
          cat > toolchain-smoketest/Cargo.toml <<'EOF'
          [package]
          name = "toolchain-smoketest"
          version = "0.1.0"
          edition = "2021"
          build = "build.rs"

          [build-dependencies]
          cc = "1"
          cmake = "0.1"
          EOF

          # src/main.rs
          cat > toolchain-smoketest/src/main.rs <<'EOF'
          extern "C" {
              fn hello_c() -> i32;
              fn hello_cpp() -> i32;
          }
          fn main() {
              let sum = unsafe { hello_c() + hello_cpp() };
              println!("smoke-ok sum={}", sum);
          }
          EOF

          # csrc/hello.c
          cat > toolchain-smoketest/csrc/hello.c <<'EOF'
          int hello_c(void) { return 1; }
          EOF

          # cxxsrc/hello.cpp
          cat > toolchain-smoketest/cxxsrc/hello.cpp <<'EOF'
          extern "C" int hello_cpp() { return 2; }
          EOF

          # build.rs
          cat > toolchain-smoketest/build.rs <<'EOF'
          use std::{env, fs, path::PathBuf, process::Command};

          fn main() {
              println!("cargo:rerun-if-env-changed=SELFTEST_SKIP_CMAKE");
              println!("cargo:rerun-if-env-changed=CC");
              println!("cargo:rerun-if-env-changed=CXX");
              println!("cargo:rerun-if-env-changed=CFLAGS");
              println!("cargo:rerun-if-env-changed=CXXFLAGS");
              println!("cargo:rerun-if-env-changed=ASMFLAGS");

              eprintln!("== CC       = {:?}", env::var("CC").ok());
              eprintln!("== CXX      = {:?}", env::var("CXX").ok());
              eprintln!("== CFLAGS   = {:?}", env::var("CFLAGS").ok());
              eprintln!("== CXXFLAGS = {:?}", env::var("CXXFLAGS").ok());
              eprintln!("== ASMFLAGS = {:?}", env::var("ASMFLAGS").ok());

              // C
              let mut c = cc::Build::new();
              c.file("csrc/hello.c");
              if let Ok(flags) = env::var("ASMFLAGS") {
                  for f in flags.split_whitespace() { c.flag(f); }
              }
              c.compile("hello_c");

              // C++
              let mut cxx = cc::Build::new();
              cxx.cpp(true).file("cxxsrc/hello.cpp").compile("hello_cpp");

              println!("cargo:rustc-link-lib=hugetlbfs");

              let skip = env::var("SELFTEST_SKIP_CMAKE").ok().as_deref() == Some("1");
              if !skip {
                  let out = PathBuf::from(env::var("OUT_DIR").unwrap());
                  let cmake_dir = out.join("cmake-smoke");
                  fs::create_dir_all(&cmake_dir).unwrap();

                  fs::write(cmake_dir.join("CMakeLists.txt"), r#"
          cmake_minimum_required(VERSION 3.20)
          project(smoketest C CXX)
          add_executable(hello ../csrc/hello.c)
          "#).unwrap();

                  let status = Command::new("cmake")
                      .current_dir(&cmake_dir)
                      .arg("-S").arg(".")
                      .arg("-B").arg("build")
                      .status().unwrap();
                  assert!(status.success());
              }
          }
          EOF

          # build & run
          cargo build --manifest-path toolchain-smoketest/Cargo.toml -v
          cargo run   --manifest-path toolchain-smoketest/Cargo.toml -q

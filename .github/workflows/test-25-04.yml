name: Toolchain Smoketest

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref or branch to test (e.g., main, master, refs/tags/v1.2.3)"
        type: string
        default: ""
      builder_image:
        description: "Builder container image"
        type: string
        default: "docker.io/mr8c3/builder:latest"
      skip_cmake:
        description: "Skip cmake hugetlbfs/Boost check"
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  ASMFLAGS: -march=haswell
  CC: gcc-15
  CFLAGS: -march=haswell
  CXX: g++-15
  CXXFLAGS: -march=haswell -DQUILL_ACTIVE_LOG_LEVEL=QUILL_LOG_LEVEL_CRITICAL

jobs:
  smoke:
    runs-on: self-hosted
    #container:
     # image: ${{ inputs.builder_image }}
      #options: --privileged --user 0:0
    #continue-on-error: true

    steps:
      # Pick a valid ref: input if provided, else try main then master
      - name: Detect ref to checkout
        id: pickref
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_FULL: ${{ github.repository }}
          INPUT_REF: ${{ inputs.ref }}
        shell: bash
        run: |
          set -euo pipefail
          url="https://x-access-token:${GH_TOKEN}@github.com/${REPO_FULL}.git"

          pick_ref() {
            git ls-remote --exit-code "$url" "$1" >/dev/null 2>&1
          }

          if [ -n "${INPUT_REF}" ]; then
            if pick_ref "${INPUT_REF}"; then
              echo "ref=${INPUT_REF}" >> "$GITHUB_OUTPUT"; exit 0
            fi
            if pick_ref "refs/heads/${INPUT_REF}"; then
              echo "ref=refs/heads/${INPUT_REF}" >> "$GITHUB_OUTPUT"; exit 0
            fi
            echo "::error::Provided ref '${INPUT_REF}' not found in ${REPO_FULL}"; exit 1
          fi

          for CAND in refs/heads/main main refs/heads/master master; do
            if pick_ref "$CAND"; then
              echo "ref=$CAND" >> "$GITHUB_OUTPUT"; exit 0
            fi
          done

          echo "::error::Could not find 'main' or 'master' in ${REPO_FULL}"; exit 1

      - uses: actions/checkout@v4
        with:
          ref: ${{ steps.pickref.outputs.ref }}
          fetch-depth: 1

      - name: Install Rust toolchain
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
          source ~/.cargo/env
           
      - name: Create dummy crate outside workspace & build
        shell: bash
        env:
          SELFTEST_SKIP_CMAKE: "${{ inputs.skip_cmake && '1' || '0' }}"
        run: |
          set -euo pipefail
          SMOKE_DIR="${RUNNER_TEMP:-/tmp}/toolchain-smoketest"
          rm -rf "$SMOKE_DIR"
          mkdir -p "$SMOKE_DIR"/{src,csrc,cxxsrc}

          # Cargo.toml
          cat > "$SMOKE_DIR/Cargo.toml" <<'EOF'
          [package]
          name = "toolchain-smoketest"
          version = "0.1.0"
          edition = "2021"
          build = "build.rs"

          [build-dependencies]
          cc = "1"
          cmake = "0.1"
          EOF

          # src/main.rs
          cat > "$SMOKE_DIR/src/main.rs" <<'EOF'
          extern "C" {
              fn hello_c() -> i32;
              fn hello_cpp() -> i32;
          }
          fn main() {
              let sum = unsafe { hello_c() + hello_cpp() };
              println!("smoke-ok sum={}", sum);
          }
          EOF

          # C / C++
          cat > "$SMOKE_DIR/csrc/hello.c" <<'EOF'
          int hello_c(void) { return 1; }
          EOF

          cat > "$SMOKE_DIR/cxxsrc/hello.cpp" <<'EOF'
          extern "C" int hello_cpp() { return 2; }
          EOF

          # build.rs (CMake copies hello.c into its scratch dir)
          cat > "$SMOKE_DIR/build.rs" <<'EOF'
          use std::{env, fs, path::PathBuf, process::Command};
          fn main() {
              println!("cargo:rerun-if-env-changed=SELFTEST_SKIP_CMAKE");
              println!("cargo:rerun-if-env-changed=CC");
              println!("cargo:rerun-if-env-changed=CXX");
              println!("cargo:rerun-if-env-changed=CFLAGS");
              println!("cargo:rerun-if-env-changed=CXXFLAGS");
              println!("cargo:rerun-if-env-changed=ASMFLAGS");

              eprintln!("== CC       = {:?}", env::var("CC").ok());
              eprintln!("== CXX      = {:?}", env::var("CXX").ok());
              eprintln!("== CFLAGS   = {:?}", env::var("CFLAGS").ok());
              eprintln!("== CXXFLAGS = {:?}", env::var("CXXFLAGS").ok());
              eprintln!("== ASMFLAGS = {:?}", env::var("ASMFLAGS").ok());

              // Build small C object
              let mut c = cc::Build::new();
              c.file("csrc/hello.c");
              if let Ok(flags) = env::var("ASMFLAGS") {
                  for f in flags.split_whitespace() { c.flag(f); }
              }
              c.compile("hello_c");

              // Build small C++ object
              let mut cxx = cc::Build::new();
              cxx.cpp(true).file("cxxsrc/hello.cpp").compile("hello_cpp");

              println!("cargo:rustc-link-lib=hugetlbfs");

              let skip = env::var("SELFTEST_SKIP_CMAKE").ok().as_deref() == Some("1");
              if !skip {
                  let out = PathBuf::from(env::var("OUT_DIR").unwrap());
                  let cmake_dir = out.join("cmake-smoke");
                  fs::create_dir_all(&cmake_dir).unwrap();

                  // copy the C source next to CMakeLists so relative paths work
                  let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
                  fs::copy(crate_dir.join("csrc/hello.c"), cmake_dir.join("hello.c")).unwrap();

                  fs::write(
                      cmake_dir.join("CMakeLists.txt"),
                      r#"
          cmake_minimum_required(VERSION 3.20)
          project(smoketest C)
          add_executable(hello hello.c)
          "#
                  ).unwrap();

                  let status = Command::new("cmake")
                      .current_dir(&cmake_dir)
                      .arg("-S").arg(".")
                      .arg("-B").arg("build")
                      .status().unwrap();
                  assert!(status.success(), "cmake smoke check failed");
              }
          }
          EOF

          cargo build --manifest-path "$SMOKE_DIR/Cargo.toml" -v
          cargo run   --manifest-path "$SMOKE_DIR/Cargo.toml" -q

      - name: Show binary output path
        shell: bash
        run: |
          SMOKE_DIR="${RUNNER_TEMP:-/tmp}/toolchain-smoketest"
          ls -l "$SMOKE_DIR/target/debug/toolchain-smoketest" || true
